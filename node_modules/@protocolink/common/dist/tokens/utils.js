"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unifyTokens = exports.unifyTokensByCustomTokens = exports.getUnifiedTokens = exports.getCustomTokens = exports.sortByAddress = exports.getWrappedNativeToken = exports.getNativeToken = exports.toTokenMap = exports.avalancheTokens = exports.arbitrumTokens = exports.iotaTokens = exports.baseTokens = exports.polygonZkevmTokens = exports.metisTokens = exports.zksyncTokens = exports.polygonTokens = exports.gnosisTokens = exports.bnbTokens = exports.optimismTokens = exports.mainnetTokens = void 0;
const tslib_1 = require("tslib");
const networks_1 = require("../networks");
const constants_1 = require("./constants");
const token_1 = require("./token");
const arbitrum_json_1 = tslib_1.__importDefault(require("./data/arbitrum.json"));
const avalanche_json_1 = tslib_1.__importDefault(require("./data/avalanche.json"));
const http_1 = require("../utils/http");
const base_json_1 = tslib_1.__importDefault(require("./data/base.json"));
const bnb_json_1 = tslib_1.__importDefault(require("./data/bnb.json"));
const gnosis_json_1 = tslib_1.__importDefault(require("./data/gnosis.json"));
const iota_json_1 = tslib_1.__importDefault(require("./data/iota.json"));
const mainnet_json_1 = tslib_1.__importDefault(require("./data/mainnet.json"));
const metis_json_1 = tslib_1.__importDefault(require("./data/metis.json"));
const optimism_json_1 = tslib_1.__importDefault(require("./data/optimism.json"));
const polygon_json_1 = tslib_1.__importDefault(require("./data/polygon.json"));
const polygonZkevm_json_1 = tslib_1.__importDefault(require("./data/polygonZkevm.json"));
const sortBy_1 = tslib_1.__importDefault(require("lodash/sortBy"));
const zksync_json_1 = tslib_1.__importDefault(require("./data/zksync.json"));
exports.mainnetTokens = toTokenMap(mainnet_json_1.default);
exports.optimismTokens = toTokenMap(optimism_json_1.default);
exports.bnbTokens = toTokenMap(bnb_json_1.default);
exports.gnosisTokens = toTokenMap(gnosis_json_1.default);
exports.polygonTokens = toTokenMap(polygon_json_1.default);
exports.zksyncTokens = toTokenMap(zksync_json_1.default);
exports.metisTokens = toTokenMap(metis_json_1.default);
exports.polygonZkevmTokens = toTokenMap(polygonZkevm_json_1.default);
exports.baseTokens = toTokenMap(base_json_1.default);
exports.iotaTokens = toTokenMap(iota_json_1.default);
exports.arbitrumTokens = toTokenMap(arbitrum_json_1.default);
exports.avalancheTokens = toTokenMap(avalanche_json_1.default);
function toTokenMap(tokenObjectMap) {
    return Object.keys(tokenObjectMap).reduce((accumulator, symbol) => {
        accumulator[symbol] = new token_1.Token(tokenObjectMap[symbol]);
        return accumulator;
    }, {});
}
exports.toTokenMap = toTokenMap;
function getNativeToken(chainId) {
    return new token_1.Token((0, networks_1.getNetwork)(chainId).nativeToken);
}
exports.getNativeToken = getNativeToken;
function getWrappedNativeToken(chainId) {
    return new token_1.Token((0, networks_1.getNetwork)(chainId).wrappedNativeToken);
}
exports.getWrappedNativeToken = getWrappedNativeToken;
function sortByAddress(tokenOrAmounts) {
    return (0, sortBy_1.default)(tokenOrAmounts, (tokenOrAmount) => {
        const address = (0, token_1.isTokenTypes)(tokenOrAmount) ? tokenOrAmount.address : tokenOrAmount.token.address;
        return address.toLowerCase();
    });
}
exports.sortByAddress = sortByAddress;
function convertTokensToTokensByAddress(tokensBySymbol) {
    return Object.fromEntries(Object.values(tokensBySymbol).map((token) => [token.address, token]));
}
// Map tokens by chain ID and address
const customTokenMap = {
    [networks_1.ChainId.mainnet]: convertTokensToTokensByAddress(exports.mainnetTokens),
    [networks_1.ChainId.optimism]: convertTokensToTokensByAddress(exports.optimismTokens),
    [networks_1.ChainId.bnb]: convertTokensToTokensByAddress(exports.bnbTokens),
    [networks_1.ChainId.gnosis]: convertTokensToTokensByAddress(exports.gnosisTokens),
    [networks_1.ChainId.polygon]: convertTokensToTokensByAddress(exports.polygonTokens),
    [networks_1.ChainId.zksync]: convertTokensToTokensByAddress(exports.zksyncTokens),
    [networks_1.ChainId.metis]: convertTokensToTokensByAddress(exports.metisTokens),
    [networks_1.ChainId.polygonZkevm]: convertTokensToTokensByAddress(exports.polygonZkevmTokens),
    [networks_1.ChainId.base]: convertTokensToTokensByAddress(exports.baseTokens),
    [networks_1.ChainId.iota]: convertTokensToTokensByAddress(exports.iotaTokens),
    [networks_1.ChainId.arbitrum]: convertTokensToTokensByAddress(exports.arbitrumTokens),
    [networks_1.ChainId.avalanche]: convertTokensToTokensByAddress(exports.avalancheTokens),
};
// Map tokens by address
function getCustomTokens(chainId) {
    return customTokenMap[chainId];
}
exports.getCustomTokens = getCustomTokens;
// Cache unified tokens by chain ID and address
const unifiedTokenMapCache = {};
// Map tokens by address
async function getUnifiedTokens(chainId) {
    if (unifiedTokenMapCache[chainId])
        return unifiedTokenMapCache[chainId];
    const customTokenMap = getCustomTokens(chainId);
    let tokenMap = {};
    try {
        const tokens = await getTokens(chainId);
        tokenMap = Object.fromEntries(tokens.map((token) => [token.address, token]));
    }
    catch (error) {
        console.error('Failed to fetch external tokens:', error);
    }
    // Merge tokens, custom tokens take precedence
    unifiedTokenMapCache[chainId] = { ...tokenMap, ...customTokenMap };
    return unifiedTokenMapCache[chainId];
}
exports.getUnifiedTokens = getUnifiedTokens;
function isTokenArray(tokens) {
    return Array.isArray(tokens) && !Array.isArray(tokens[0]) && typeof tokens[0] === 'object';
}
function isTokenPairArray(tokens) {
    return Array.isArray(tokens) && tokens.length > 0 && Array.isArray(tokens[0]);
}
function isTokenRecord(tokens) {
    return (typeof tokens === 'object' &&
        !Array.isArray(tokens) &&
        typeof Object.values(tokens)[0][0] === 'object' &&
        'address' in Object.values(tokens)[0][0]);
}
function isTokenPairRecord(tokens) {
    return (typeof tokens === 'object' &&
        !Array.isArray(tokens) &&
        Array.isArray(Object.values(tokens)[0][0]) &&
        'address' in Object.values(tokens)[0][0][0]);
}
//  Replaces tokens in various formats with unified tokens based on their addresses.
function replaceTokens(tokens, tokenMap) {
    function replaceToken(token) {
        return tokenMap[token.address] || token;
    }
    if (isTokenArray(tokens))
        return tokens.map(replaceToken);
    if (isTokenPairArray(tokens)) {
        return tokens.map(([token1, token2]) => [replaceToken(token1), replaceToken(token2)]);
    }
    if (isTokenRecord(tokens)) {
        const tokenRecord = {};
        for (const key in tokens) {
            tokenRecord[key] = tokens[key].map(replaceToken);
        }
        return tokenRecord;
    }
    if (isTokenPairRecord(tokens)) {
        const tokenPairRecord = {};
        for (const key in tokens) {
            tokenPairRecord[key] = tokens[key].map(([token1, token2]) => [replaceToken(token1), replaceToken(token2)]);
        }
        return tokenPairRecord;
    }
    return tokens;
}
function unifyTokensByCustomTokens(chainId, tokens) {
    return replaceTokens(tokens, getCustomTokens(chainId));
}
exports.unifyTokensByCustomTokens = unifyTokensByCustomTokens;
async function unifyTokens(chainId, tokens) {
    return replaceTokens(tokens, await getUnifiedTokens(chainId));
}
exports.unifyTokens = unifyTokens;
async function getTokens(chainId) {
    switch (chainId) {
        case networks_1.ChainId.metis: {
            return await getMetisTokens();
        }
        case networks_1.ChainId.iota: {
            return await getIotaTokens();
        }
        case networks_1.ChainId.polygonZkevm: {
            return await getPolygonZkevmTokens();
        }
        default: {
            return await get1InchTokens(chainId);
        }
    }
}
async function get1InchTokens(chainId) {
    const { data } = await http_1.axios.get(`https://tokens.1inch.io/v1.2/${chainId}`);
    const nativeToken = getNativeToken(chainId);
    const elasticAddress = constants_1.ELASTIC_ADDRESS.toLowerCase();
    const tokens = Object.values(data).map(({ symbol, name, address, decimals, logoURI }) => address === elasticAddress ? nativeToken : new token_1.Token(chainId, address, decimals, symbol, name, logoURI));
    return tokens;
}
async function getMetisTokens() {
    const chainId = networks_1.ChainId.metis;
    const { data } = await http_1.axios.get(`https://tokens.coingecko.com/metis-andromeda/all.json`);
    const tokens = [getNativeToken(chainId)];
    for (const { address, name, symbol, decimals, logoURI } of data.tokens) {
        if (address === '0xdeaddeaddeaddeaddeaddeaddeaddeaddead0000')
            continue;
        tokens.push(new token_1.Token(chainId, address, decimals, symbol, name, logoURI));
    }
    return tokens;
}
async function getIotaTokens() {
    const chainId = networks_1.ChainId.iota;
    const { data } = await http_1.axios.get(`https://raw.githubusercontent.com/MagicSea-Finance/tokenlist/main/token.default.json`);
    const tokens = [getNativeToken(chainId)];
    for (const { name, symbol, decimals, logoURI, address, chainId } of data.tokens) {
        if (chainId !== networks_1.ChainId.iota)
            continue;
        tokens.push(new token_1.Token(chainId, address, decimals, symbol, name, logoURI));
    }
    return tokens;
}
async function getPolygonZkevmTokens() {
    const chainId = networks_1.ChainId.polygonZkevm;
    const { data } = await http_1.axios.get(`https://unpkg.com/quickswap-default-token-list@1.3.48/build/quickswap-default.tokenlist.json`);
    const tokens = [getNativeToken(chainId)];
    for (const { name, symbol, decimals, logoURI, address, chainId } of data.tokens) {
        if (chainId !== networks_1.ChainId.polygonZkevm)
            continue;
        tokens.push(new token_1.Token(chainId, address, decimals, symbol, name, logoURI));
    }
    return tokens;
}
//# sourceMappingURL=utils.js.map