"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Web3Toolkit = void 0;
const tslib_1 = require("tslib");
const ethers_1 = require("ethers");
const networks_1 = require("./networks");
const tokens_1 = require("./tokens");
const contracts_1 = require("./contracts");
const zk = tslib_1.__importStar(require("zksync-web3"));
class Web3Toolkit {
    constructor(chainId, provider) {
        this.chainId = chainId;
        this.network = (0, networks_1.getNetwork)(chainId);
        this.provider = provider
            ? provider
            : chainId === networks_1.ChainId.zksync
                ? new zk.Provider(this.network.rpcUrl)
                : new ethers_1.providers.JsonRpcProvider(this.network.rpcUrl);
        this.nativeToken = new tokens_1.Token(this.network.nativeToken);
        this.wrappedNativeToken = new tokens_1.Token(this.network.wrappedNativeToken);
    }
    get erc20Iface() {
        if (!this._erc20Iface) {
            this._erc20Iface = contracts_1.ERC20__factory.createInterface();
        }
        return this._erc20Iface;
    }
    get multicall3Iface() {
        if (!this._multicall3Iface) {
            this._multicall3Iface = contracts_1.Multicall3__factory.createInterface();
        }
        return this._multicall3Iface;
    }
    get multicall3() {
        if (!this._multicall3) {
            this._multicall3 = contracts_1.Multicall3__factory.connect(this.network.multicall3Address, this.provider);
        }
        return this._multicall3;
    }
    async getToken(tokenOrAddress) {
        let token;
        if (typeof tokenOrAddress === 'string') {
            const tokenAddress = tokenOrAddress;
            if (tokenAddress === this.nativeToken.address || tokenAddress === tokens_1.ELASTIC_ADDRESS) {
                token = this.nativeToken;
            }
            else {
                const calls = [
                    { target: tokenAddress, callData: this.erc20Iface.encodeFunctionData('decimals') },
                    { target: tokenAddress, callData: this.erc20Iface.encodeFunctionData('symbol') },
                    { target: tokenAddress, callData: this.erc20Iface.encodeFunctionData('name') },
                ];
                const { returnData } = await this.multicall3.callStatic.aggregate(calls);
                const [decimals] = this.erc20Iface.decodeFunctionResult('decimals', returnData[0]);
                let symbol;
                let name;
                try {
                    [symbol] = this.erc20Iface.decodeFunctionResult('symbol', returnData[1]);
                    [name] = this.erc20Iface.decodeFunctionResult('name', returnData[2]);
                }
                catch (_a) {
                    symbol = ethers_1.utils.parseBytes32String(returnData[1]);
                    name = ethers_1.utils.parseBytes32String(returnData[2]);
                }
                token = new tokens_1.Token(this.chainId, tokenAddress, decimals, symbol, name);
            }
        }
        else if ((0, tokens_1.isTokenObject)(tokenOrAddress)) {
            token = tokens_1.Token.from(tokenOrAddress);
        }
        else {
            token = tokenOrAddress;
        }
        return token;
    }
    async getTokens(tokenAddresses) {
        const calls = [];
        for (const tokenAddress of tokenAddresses) {
            if (tokenAddress !== this.nativeToken.address && tokenAddress !== tokens_1.ELASTIC_ADDRESS) {
                calls.push({ target: tokenAddress, callData: this.erc20Iface.encodeFunctionData('decimals') });
                calls.push({ target: tokenAddress, callData: this.erc20Iface.encodeFunctionData('symbol') });
                calls.push({ target: tokenAddress, callData: this.erc20Iface.encodeFunctionData('name') });
            }
        }
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        const tokens = [];
        let j = 0;
        for (const tokenAddress of tokenAddresses) {
            if (tokenAddress === this.nativeToken.address || tokenAddress === tokens_1.ELASTIC_ADDRESS) {
                tokens.push(this.nativeToken);
            }
            else {
                const [decimals] = this.erc20Iface.decodeFunctionResult('decimals', returnData[j]);
                j++;
                let symbol;
                let name;
                try {
                    [symbol] = this.erc20Iface.decodeFunctionResult('symbol', returnData[j]);
                    j++;
                    [name] = this.erc20Iface.decodeFunctionResult('name', returnData[j]);
                    j++;
                }
                catch (_a) {
                    symbol = ethers_1.utils.parseBytes32String(returnData[j]);
                    j++;
                    name = ethers_1.utils.parseBytes32String(returnData[j]);
                    j++;
                }
                tokens.push(new tokens_1.Token(this.chainId, tokenAddress, decimals, symbol, name));
            }
        }
        return tokens;
    }
    async getBalance(account, tokenOrAddress, blockTag) {
        const token = await this.getToken(tokenOrAddress);
        const balanceWei = token.isNative
            ? await this.provider.getBalance(account, blockTag)
            : await contracts_1.ERC20__factory.connect(token.address, this.provider).balanceOf(account, { blockTag });
        const balance = new tokens_1.TokenAmount(token).setWei(balanceWei);
        return balance;
    }
    async getAllowance(account, tokenOrAddress, spender) {
        const erc20 = contracts_1.ERC20__factory.connect(tokens_1.Token.getAddress(tokenOrAddress), this.provider);
        const allowance = await erc20.allowance(account, spender);
        return allowance;
    }
    async getAllowances(account, tokenOrAddresses, spender) {
        const calls = tokenOrAddresses.map((tokenOrAddress) => ({
            target: tokens_1.Token.getAddress(tokenOrAddress),
            callData: this.erc20Iface.encodeFunctionData('allowance', [account, spender]),
        }));
        const { returnData } = await this.multicall3.callStatic.aggregate(calls);
        const allowances = [];
        for (let i = 0; i < tokenOrAddresses.length; i++) {
            const [allowance] = this.erc20Iface.decodeFunctionResult('allowance', returnData[i]);
            allowances.push(allowance);
        }
        return allowances;
    }
}
exports.Web3Toolkit = Web3Toolkit;
//# sourceMappingURL=web3-toolkit.js.map