"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RouterKit = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const permit2_sdk_1 = require("@uniswap/permit2-sdk");
const constants_1 = require("./constants");
const common = tslib_1.__importStar(require("@protocolink/common"));
const configs_1 = require("./configs");
const router_utils_1 = require("./router-utils");
const agentImplementationAddressMap = {};
const defaultCollectorMap = {};
const defaultReferralMap = {};
const permit2AddressMap = {};
const agentMap = {};
class RouterKit extends common.Web3Toolkit {
    get routerIface() {
        if (!this._routerIface) {
            this._routerIface = contracts_1.Router__factory.createInterface();
        }
        return this._routerIface;
    }
    get router() {
        if (!this._router) {
            this._router = contracts_1.Router__factory.connect((0, configs_1.getContractAddress)(this.chainId, 'Router'), this.provider);
        }
        return this._router;
    }
    async getAgentImplementationAddress() {
        if (!agentImplementationAddressMap[this.chainId]) {
            agentImplementationAddressMap[this.chainId] = await this.router.agentImplementation();
        }
        return agentImplementationAddressMap[this.chainId];
    }
    async getDefaultCollector() {
        if (!defaultCollectorMap[this.chainId]) {
            defaultCollectorMap[this.chainId] = await this.router.defaultCollector();
        }
        return defaultCollectorMap[this.chainId];
    }
    async getDefaultReferral() {
        if (!defaultReferralMap[this.chainId]) {
            defaultReferralMap[this.chainId] = await this.router.defaultReferral();
        }
        return defaultReferralMap[this.chainId];
    }
    async getPermit2Address() {
        if (!permit2AddressMap[this.chainId]) {
            const agentImplementationAddress = await this.getAgentImplementationAddress();
            const agentImplementation = contracts_1.Agent__factory.connect(agentImplementationAddress, this.provider);
            permit2AddressMap[this.chainId] = await agentImplementation.permit2();
        }
        return permit2AddressMap[this.chainId];
    }
    get permit2Iface() {
        if (!this._permit2Iface) {
            this._permit2Iface = contracts_1.Permit2__factory.createInterface();
        }
        return this._permit2Iface;
    }
    async calcAgent(account) {
        var _a;
        if (!((_a = agentMap[this.chainId]) === null || _a === void 0 ? void 0 : _a[account])) {
            const agent = await this.router.calcAgent(account);
            if (agentMap[this.chainId]) {
                agentMap[this.chainId][account] = agent;
            }
            else {
                agentMap[this.chainId] = { [account]: agent };
            }
        }
        return agentMap[this.chainId][account];
    }
    async getPermit2PermitData(account, inputs) {
        const agent = await this.calcAgent(account);
        const permit2Address = await this.getPermit2Address();
        const sigDeadline = (0, router_utils_1.getDeadline)(constants_1.PERMIT_SIG_DEADLINE);
        const details = [];
        if (!inputs.isEmpty) {
            const calls = inputs.map((fund) => ({
                target: permit2Address,
                callData: this.permit2Iface.encodeFunctionData('allowance', [account, fund.token.address, agent]),
            }));
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            inputs.forEach((fund, i) => {
                const [amount, expiration, nonce] = this.permit2Iface.decodeFunctionResult('allowance', returnData[i]);
                if (amount.lt(fund.amountWei) || expiration <= sigDeadline) {
                    details.push({
                        token: fund.token.address,
                        amount: permit2_sdk_1.MaxUint160.toHexString(),
                        expiration: (0, router_utils_1.getDeadline)(constants_1.PERMIT_EXPIRATION),
                        nonce,
                    });
                }
            });
        }
        if (details.length === 0)
            return;
        const permit = details.length === 1
            ? { details: details[0], spender: agent, sigDeadline }
            : { details: details, spender: agent, sigDeadline };
        const permitData = permit2_sdk_1.AllowanceTransfer.getPermitData(permit, permit2Address, this.chainId);
        return permitData;
    }
    async getPermit2Approvals(account, inputs) {
        const approvals = [];
        if (!inputs.isEmpty) {
            const agent = await this.calcAgent(account);
            const permit2Address = await this.getPermit2Address();
            const calls = inputs.map((fund) => ({
                target: permit2Address,
                callData: this.permit2Iface.encodeFunctionData('allowance', [account, fund.token.address, agent]),
            }));
            const { returnData } = await this.multicall3.callStatic.aggregate(calls);
            inputs.forEach((fund, i) => {
                const [amount, expiration] = this.permit2Iface.decodeFunctionResult('allowance', returnData[i]);
                if (amount.lt(fund.amountWei) || expiration <= (0, router_utils_1.getDeadline)(constants_1.PERMIT_SIG_DEADLINE)) {
                    approvals.push({
                        to: permit2Address,
                        data: this.permit2Iface.encodeFunctionData('approve', [
                            fund.token.address,
                            agent,
                            permit2_sdk_1.MaxUint160.toHexString(),
                            (0, router_utils_1.getDeadline)(constants_1.PERMIT_EXPIRATION),
                        ]),
                    });
                }
            });
        }
        return approvals;
    }
    encodePermit2Permit(account, permit, sig) {
        let data;
        if ((0, router_utils_1.isPermitSingle)(permit)) {
            data = this.permit2Iface.encodeFunctionData('permit(address,((address,uint160,uint48,uint48),address,uint256),bytes)', [account, permit, sig]);
        }
        else {
            data = this.permit2Iface.encodeFunctionData('permit(address,((address,uint160,uint48,uint48)[],address,uint256),bytes)', [account, permit, sig]);
        }
        return data;
    }
    async encodePermit2TransferFrom(account, inputs) {
        const agent = await this.calcAgent(account);
        let data;
        if (inputs.length === 1) {
            const input = inputs.at(0);
            data = this.permit2Iface.encodeFunctionData('transferFrom(address,address,uint160,address)', [
                account,
                agent,
                input.amountWei,
                input.token.address,
            ]);
        }
        else {
            const details = inputs.map((input) => ({
                from: account,
                to: agent,
                amount: input.amountWei,
                token: input.token.address,
            }));
            data = this.permit2Iface.encodeFunctionData('transferFrom((address,address,uint160,address)[])', [details]);
        }
        return data;
    }
    buildLogicBatchTypedData(values) {
        const typedData = {
            domain: { name: 'Protocolink', version: '1', chainId: this.chainId, verifyingContract: this.router.address },
            types: constants_1.LOGIC_BATCH_TYPED_DATA_TYPES,
            values,
        };
        return typedData;
    }
    buildExecuteTransactionRequest(options) {
        const { permit2Datas = [], routerLogics, tokensReturn = [], value = 0 } = options;
        const data = this.routerIface.encodeFunctionData('execute', [permit2Datas, routerLogics, tokensReturn]);
        return { to: this.router.address, data, value };
    }
    buildExecuteWithSignerFeeTransactionRequest(options) {
        const { permit2Datas = [], routerBatchLogics, signer, signature, tokensReturn = [], value = 0 } = options;
        const data = this.routerIface.encodeFunctionData('executeWithSignerFee', [
            permit2Datas,
            routerBatchLogics,
            signer,
            signature,
            tokensReturn,
        ]);
        return { to: this.router.address, data, value };
    }
}
exports.RouterKit = RouterKit;
//# sourceMappingURL=router-kit.js.map