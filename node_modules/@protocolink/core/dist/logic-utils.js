"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.newCallbackParams = exports.newLogic = exports.newLogicInput = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("./contracts");
const constants_1 = require("./constants");
const ethers_1 = require("ethers");
const logic_types_1 = require("./logic-types");
const common = tslib_1.__importStar(require("@protocolink/common"));
const tiny_invariant_1 = tslib_1.__importDefault(require("tiny-invariant"));
function newLogicInput(options) {
    const { input } = options;
    let balanceBps;
    let amountOrOffset;
    if (options.balanceBps && options.amountOffset !== undefined) {
        (0, tiny_invariant_1.default)(common.validateBps(options.balanceBps), 'balanceBps is invalid');
        balanceBps = options.balanceBps;
        amountOrOffset = options.amountOffset;
    }
    else {
        balanceBps = constants_1.BPS_NOT_USED;
        amountOrOffset = input.amountWei;
    }
    return { token: input.token.elasticAddress, balanceBps, amountOrOffset };
}
exports.newLogicInput = newLogicInput;
function newLogic(options) {
    const { to, data, inputs = [], wrapMode = logic_types_1.WrapMode.none, approveTo = ethers_1.constants.AddressZero, callback = ethers_1.constants.AddressZero, } = options;
    return { to, data, inputs, wrapMode, approveTo, callback };
}
exports.newLogic = newLogic;
function newCallbackParams(logics) {
    return `0x${contracts_1.Agent__factory.createInterface().encodeFunctionData('executeByCallback', [logics]).substring(10)}`;
}
exports.newCallbackParams = newCallbackParams;
//# sourceMappingURL=logic-utils.js.map